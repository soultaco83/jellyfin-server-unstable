name: Reset to Upstream and Merge PRs

on:
  schedule:
    - cron: '0 8 * * *'  # Runs at midnight EST sunday
  workflow_dispatch:
    inputs:
      pr_numbers:
        description: 'Comma-separated list of PR numbers to merge'
        required: false
        default: ''
      auto_resolve_conflicts:
        description: 'Auto-resolve conflicts in favor of our version (HEAD)'
        required: false
        type: boolean
        default: true
      conflict_resolution_strategy:
        description: 'How to resolve conflicts: auto-head (our version), auto-pr (PR version), or skip (skip conflicted PRs)'
        required: false
        type: choice
        options:
          - auto-head
          - auto-pr
          - skip
        default: 'auto-head'
      pr_specific_strategies:
        description: 'Per-PR conflict strategies (format: "14795:auto-pr,14800:auto-head") - overrides global strategy'
        required: false
        default: ''

permissions:
  contents: write
  pull-requests: read

env:
  # Default PR numbers to use for both scheduled and manual runs (if not specified)
  # This list is automatically updated - merged PRs are removed after successful runs
  # To add new PRs: edit this line and add the PR numbers to the list
  DEFAULT_PR_NUMBERS: '12775,13892,13977,14155,14608,14788,14809,14824,14879,14882,14897'
  #
  # Token for authentication
  GH_TOKEN: ${{ secrets.PAT_TOKEN || github.token }}

jobs:
  reset-and-merge:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ env.GH_TOKEN }}
          persist-credentials: true

      - name: Verify authentication
        run: |
          # Check if PAT_TOKEN is available
          if [ -n "${{ secrets.PAT_TOKEN }}" ]; then
            echo "✅ PAT_TOKEN is configured"
          else
            echo "✅ Using default GITHUB_TOKEN"
            echo "Note: For workflow self-updating, set up PAT_TOKEN secret"
          fi

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"
          # Set merge strategy to avoid merge commit messages prompts
          git config pull.rebase false

      - name: Add upstream remote
        run: |
          # Add upstream without authentication (public repo)
          git remote add upstream https://github.com/jellyfin/jellyfin.git || \
          git remote set-url upstream https://github.com/jellyfin/jellyfin.git
          
          # Fix origin URL to include authentication token
          git remote set-url origin https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git

      - name: Fetch all remotes
        run: |
          echo "Current remotes:"
          git remote -v
          
          echo "Fetching from origin..."
          git fetch origin
          
          echo "Fetching from upstream..."
          git fetch upstream --prune
          
          echo "Fetched latest changes from all remotes"

      - name: Merge upstream changes
        id: merge_upstream
        run: |
          echo "Current branch: $(git branch --show-current)"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "Upstream commit: $(git rev-parse upstream/master)"
          
          git checkout master
          
          # Attempt to merge upstream/master
          if git merge upstream/master --no-ff -m "Merge latest upstream Jellyfin changes"; then
            echo "✅ Successfully merged upstream changes"
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "had_conflicts=false" >> $GITHUB_OUTPUT
          else
            echo "⚠️ Merge conflicts detected in the following files:"
            git diff --name-only --diff-filter=U
            
            # Store conflict info for later
            git diff --name-only --diff-filter=U > /tmp/conflict_files.txt
            
            echo "had_conflicts=true" >> $GITHUB_OUTPUT
            echo "merge_success=false" >> $GITHUB_OUTPUT
            
            # Create a summary of conflicts
            echo "## ⚠️ Merge Conflicts Detected" > /tmp/conflict_summary.txt
            echo "" >> /tmp/conflict_summary.txt
            echo "The following files have conflicts between your custom changes and upstream:" >> /tmp/conflict_summary.txt
            echo "" >> /tmp/conflict_summary.txt
            while IFS= read -r file; do
              echo "- \`$file\`" >> /tmp/conflict_summary.txt
            done < /tmp/conflict_files.txt
            echo "" >> /tmp/conflict_summary.txt
            echo "**Action Required:** Please manually review and resolve these conflicts." >> /tmp/conflict_summary.txt
            echo "The workflow has been stopped to prevent automatic resolution that might lose your changes." >> /tmp/conflict_summary.txt
            
            # Abort the merge
            git merge --abort
            
            # Exit with error to stop the workflow
            exit 1
          fi

      - name: Check PR status (merged, closed, or open)
        if: steps.merge_upstream.outputs.merge_success == 'true'
        id: check_pr_status
        run: |
          # Use the input PR numbers if provided, otherwise use the default PR numbers
          PR_NUMBERS="${{ github.event.inputs.pr_numbers }}"
          if [ -z "$PR_NUMBERS" ]; then
            PR_NUMBERS="${{ env.DEFAULT_PR_NUMBERS }}"
          fi

          IFS=',' read -ra PR_ARRAY <<< "$PR_NUMBERS"

          echo "## PR Status Check" > pr_status.txt
          echo "" >> pr_status.txt

          MERGED_UPSTREAM_PRS=""
          CLOSED_PRS=""
          UNMERGED_PRS=""

          for PR_NUMBER in "${PR_ARRAY[@]}"; do
            PR_NUMBER=$(echo $PR_NUMBER | xargs)  # Trim whitespace

            # Check if PR is already merged upstream
            if git log upstream/master --grep="Merge pull request #$PR_NUMBER" --oneline | grep -q "$PR_NUMBER"; then
              echo "✅ PR $PR_NUMBER is already merged upstream" >> pr_status.txt
              if [ -z "$MERGED_UPSTREAM_PRS" ]; then
                MERGED_UPSTREAM_PRS="$PR_NUMBER"
              else
                MERGED_UPSTREAM_PRS="$MERGED_UPSTREAM_PRS,$PR_NUMBER"
              fi
            else
              # Check if PR is closed (but not merged) using GitHub CLI
              echo "Checking PR $PR_NUMBER status via GitHub API..."
              
              # Use GitHub CLI to check PR status
              PR_STATE=$(gh pr view $PR_NUMBER --repo jellyfin/jellyfin --json state,merged -q '.state + ":" + (.merged|tostring)' 2>/dev/null || echo "UNKNOWN:false")
              
              STATE=$(echo "$PR_STATE" | cut -d':' -f1)
              IS_MERGED=$(echo "$PR_STATE" | cut -d':' -f2)
              
              if [ "$STATE" = "CLOSED" ] && [ "$IS_MERGED" = "false" ]; then
                echo "❌ PR $PR_NUMBER is closed (not merged)" >> pr_status.txt
                if [ -z "$CLOSED_PRS" ]; then
                  CLOSED_PRS="$PR_NUMBER"
                else
                  CLOSED_PRS="$CLOSED_PRS,$PR_NUMBER"
                fi
              elif [ "$STATE" = "OPEN" ] || [ "$STATE" = "UNKNOWN" ]; then
                echo "⭕ PR $PR_NUMBER needs to be merged" >> pr_status.txt
                echo "$PR_NUMBER" >> prs_to_merge.txt
                if [ -z "$UNMERGED_PRS" ]; then
                  UNMERGED_PRS="$PR_NUMBER"
                else
                  UNMERGED_PRS="$UNMERGED_PRS,$PR_NUMBER"
                fi
              fi
            fi
          done

          echo "PR Status:"
          cat pr_status.txt

          # Set outputs for README update
          echo "merged_upstream_prs=$MERGED_UPSTREAM_PRS" >> $GITHUB_OUTPUT
          echo "closed_prs=$CLOSED_PRS" >> $GITHUB_OUTPUT
          echo "unmerged_prs=$UNMERGED_PRS" >> $GITHUB_OUTPUT

      - name: Merge PRs
        if: steps.merge_upstream.outputs.merge_success == 'true'
        id: merge_prs
        run: |
          if [ ! -f "prs_to_merge.txt" ]; then
            echo "All PRs are either merged upstream or closed!"
            echo "newly_merged_prs=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "## Merge Results" > merge_results.txt
          echo "" >> merge_results.txt

          NEWLY_MERGED_PRS=""
          
          # Parse per-PR strategies if provided
          declare -A PR_STRATEGIES
          if [ -n "${{ github.event.inputs.pr_specific_strategies }}" ]; then
            echo "Parsing per-PR conflict strategies..."
            IFS=',' read -ra STRATEGY_PAIRS <<< "${{ github.event.inputs.pr_specific_strategies }}"
            for pair in "${STRATEGY_PAIRS[@]}"; do
              if [[ $pair == *":"* ]]; then
                PR=$(echo "$pair" | cut -d':' -f1 | xargs)
                STRATEGY=$(echo "$pair" | cut -d':' -f2 | xargs)
                PR_STRATEGIES[$PR]=$STRATEGY
                echo "  PR $PR: $STRATEGY"
              fi
            done
          fi

          while IFS= read -r PR_NUMBER; do
            echo "Processing PR $PR_NUMBER"

            # Fetch the PR branch
            if git fetch upstream pull/$PR_NUMBER/head:pr-$PR_NUMBER; then
              echo "Fetched PR $PR_NUMBER successfully"

              # Check if this PR can be merged cleanly
              MERGE_BASE=$(git merge-base HEAD pr-$PR_NUMBER)
              if git merge-tree $MERGE_BASE HEAD pr-$PR_NUMBER | grep -q '^<<<<<<<'; then
                # Determine conflict resolution strategy for this PR
                STRATEGY="${PR_STRATEGIES[$PR_NUMBER]:-${{ github.event.inputs.conflict_resolution_strategy || 'auto-head' }}}"
                
                echo "⚠️ PR $PR_NUMBER has conflicts - using strategy: $STRATEGY" >> merge_results.txt
                
                case $STRATEGY in
                  "auto-head")
                    echo "Attempting merge with auto-resolution (favoring HEAD/our version)..."
                    if git merge pr-$PR_NUMBER --no-ff -m "Merge upstream changes from PR-$PR_NUMBER"; then
                      echo "✅ Merged PR $PR_NUMBER successfully (auto-resolved conflicts)" >> merge_results.txt
                      
                      if [ -z "$NEWLY_MERGED_PRS" ]; then
                        NEWLY_MERGED_PRS="$PR_NUMBER"
                      else
                        NEWLY_MERGED_PRS="$NEWLY_MERGED_PRS,$PR_NUMBER"
                      fi
                      
                      git branch -D pr-$PR_NUMBER
                    else
                      # Merge failed, try manual conflict resolution
                      echo "Auto-merge failed, resolving conflicts manually (HEAD wins)..."
                      git checkout --ours .
                      git add .
                      git commit -m "Merge upstream changes from PR-$PR_NUMBER (resolved conflicts favoring HEAD)"
                      echo "✅ Merged PR $PR_NUMBER with manual conflict resolution (HEAD wins)" >> merge_results.txt
                      
                      if [ -z "$NEWLY_MERGED_PRS" ]; then
                        NEWLY_MERGED_PRS="$PR_NUMBER"
                      else
                        NEWLY_MERGED_PRS="$NEWLY_MERGED_PRS,$PR_NUMBER"
                      fi
                      
                      git branch -D pr-$PR_NUMBER
                    fi
                    ;;
                  "auto-pr")
                    echo "Attempting merge with auto-resolution (favoring PR version)..."
                    if git merge pr-$PR_NUMBER --no-ff -m "Merge upstream changes from PR-$PR_NUMBER (auto-resolved conflicts favoring PR)"; then
                      echo "✅ Merged PR $PR_NUMBER successfully (auto-resolved conflicts)" >> merge_results.txt
                      
                      if [ -z "$NEWLY_MERGED_PRS" ]; then
                        NEWLY_MERGED_PRS="$PR_NUMBER"
                      else
                        NEWLY_MERGED_PRS="$NEWLY_MERGED_PRS,$PR_NUMBER"
                      fi
                      
                      git branch -D pr-$PR_NUMBER
                    else
                      # Merge failed, try manual conflict resolution
                      echo "Auto-merge failed, resolving conflicts manually (PR wins)..."
                      git checkout --theirs .
                      git add .
                      git commit -m "Merge upstream changes from PR-$PR_NUMBER (resolved conflicts favoring PR)"
                      echo "✅ Merged PR $PR_NUMBER with manual conflict resolution (PR wins)" >> merge_results.txt
                      
                      if [ -z "$NEWLY_MERGED_PRS" ]; then
                        NEWLY_MERGED_PRS="$PR_NUMBER"
                      else
                        NEWLY_MERGED_PRS="$NEWLY_MERGED_PRS,$PR_NUMBER"
                      fi
                      
                      git branch -D pr-$PR_NUMBER
                    fi
                    ;;
                  "skip")
                    echo "⏭️ Skipping PR $PR_NUMBER due to conflicts (strategy: skip)" >> merge_results.txt
                    git branch -D pr-$PR_NUMBER || true
                    ;;
                  *)
                    echo "❌ Unknown conflict resolution strategy: $STRATEGY for PR $PR_NUMBER" >> merge_results.txt
                    git branch -D pr-$PR_NUMBER || true
                    ;;
                esac
              else
                # No conflicts, merge normally
                if git merge pr-$PR_NUMBER --no-ff -m "Merge upstream changes from PR-$PR_NUMBER"; then
                  echo "✅ Merged PR $PR_NUMBER successfully" >> merge_results.txt

                  if [ -z "$NEWLY_MERGED_PRS" ]; then
                    NEWLY_MERGED_PRS="$PR_NUMBER"
                  else
                    NEWLY_MERGED_PRS="$NEWLY_MERGED_PRS,$PR_NUMBER"
                  fi

                  # Clean up the PR branch
                  git branch -D pr-$PR_NUMBER
                else
                  echo "❌ Failed to merge PR $PR_NUMBER (unexpected error)" >> merge_results.txt
                  git merge --abort
                  git branch -D pr-$PR_NUMBER || true
                fi
              fi
            else
              echo "❌ Failed to fetch PR $PR_NUMBER (PR may not exist or is closed)" >> merge_results.txt
            fi
          done < prs_to_merge.txt

          echo ""
          echo "Merge Summary:"
          cat merge_results.txt

          # Set output for README update
          echo "newly_merged_prs=$NEWLY_MERGED_PRS" >> $GITHUB_OUTPUT

      - name: Update README with current PR list
        if: steps.merge_upstream.outputs.merge_success == 'true'
        run: |
          # Get PR status information
          MERGED_UPSTREAM_PRS="${{ steps.check_pr_status.outputs.merged_upstream_prs }}"
          CLOSED_PRS="${{ steps.check_pr_status.outputs.closed_prs }}"
          UNMERGED_PRS="${{ steps.check_pr_status.outputs.unmerged_prs }}"
          NEWLY_MERGED_PRS="${{ steps.merge_prs.outputs.newly_merged_prs }}"

          echo "Updating README with current PR status..."
          echo "Merged upstream: $MERGED_UPSTREAM_PRS"
          echo "Closed without merge: $CLOSED_PRS"
          echo "Still unmerged: $UNMERGED_PRS"
          echo "Newly merged: $NEWLY_MERGED_PRS"

          # Load or create timestamp files
          MERGED_PRS_FILE=".github/merged_prs_timestamps.json"
          CLOSED_PRS_FILE=".github/closed_prs_timestamps.json"
          
          # Initialize files if they don't exist
          [ ! -f "$MERGED_PRS_FILE" ] && echo "{}" > "$MERGED_PRS_FILE"
          [ ! -f "$CLOSED_PRS_FILE" ] && echo "{}" > "$CLOSED_PRS_FILE"

          # Add current timestamp for newly merged/closed PRs
          CURRENT_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          # Record merged PRs
          if [ -n "$MERGED_UPSTREAM_PRS" ]; then
            echo "Recording merge timestamps for upstream PRs: $MERGED_UPSTREAM_PRS"
            IFS=',' read -ra MERGED_ARRAY <<< "$MERGED_UPSTREAM_PRS"
            for PR_NUMBER in "${MERGED_ARRAY[@]}"; do
              PR_NUMBER=$(echo "$PR_NUMBER" | xargs)
              cat "$MERGED_PRS_FILE" | jq --arg pr "$PR_NUMBER" --arg ts "$CURRENT_TIMESTAMP" '. + {($pr): $ts}' > "${MERGED_PRS_FILE}.tmp"
              mv "${MERGED_PRS_FILE}.tmp" "$MERGED_PRS_FILE"
            done
          fi

          # Record closed PRs
          if [ -n "$CLOSED_PRS" ]; then
            echo "Recording close timestamps for closed PRs: $CLOSED_PRS"
            IFS=',' read -ra CLOSED_ARRAY <<< "$CLOSED_PRS"
            for PR_NUMBER in "${CLOSED_ARRAY[@]}"; do
              PR_NUMBER=$(echo "$PR_NUMBER" | xargs)
              cat "$CLOSED_PRS_FILE" | jq --arg pr "$PR_NUMBER" --arg ts "$CURRENT_TIMESTAMP" '. + {($pr): $ts}' > "${CLOSED_PRS_FILE}.tmp"
              mv "${CLOSED_PRS_FILE}.tmp" "$CLOSED_PRS_FILE"
            done
          fi

          # Filter to show recent changes (last 7 days)
          SEVEN_DAYS_AGO=$(date -u -d '7 days ago' +"%Y-%m-%dT%H:%M:%SZ")
          
          # Get recently merged PRs
          RECENT_MERGED_PRS=""
          if [ -f "$MERGED_PRS_FILE" ]; then
            RECENT_PRS=$(cat "$MERGED_PRS_FILE" | jq -r --arg cutoff "$SEVEN_DAYS_AGO" 'to_entries | map(select(.value > $cutoff)) | map(.key) | join(",")')
            [ "$RECENT_PRS" != "" ] && [ "$RECENT_PRS" != "null" ] && RECENT_MERGED_PRS="$RECENT_PRS"
            
            # Clean up old entries
            cat "$MERGED_PRS_FILE" | jq --arg cutoff "$SEVEN_DAYS_AGO" 'to_entries | map(select(.value > $cutoff)) | from_entries' > "${MERGED_PRS_FILE}.tmp"
            mv "${MERGED_PRS_FILE}.tmp" "$MERGED_PRS_FILE"
          fi

          # Get recently closed PRs
          RECENT_CLOSED_PRS=""
          if [ -f "$CLOSED_PRS_FILE" ]; then
            RECENT_PRS=$(cat "$CLOSED_PRS_FILE" | jq -r --arg cutoff "$SEVEN_DAYS_AGO" 'to_entries | map(select(.value > $cutoff)) | map(.key) | join(",")')
            [ "$RECENT_PRS" != "" ] && [ "$RECENT_PRS" != "null" ] && RECENT_CLOSED_PRS="$RECENT_PRS"
            
            # Clean up old entries
            cat "$CLOSED_PRS_FILE" | jq --arg cutoff "$SEVEN_DAYS_AGO" 'to_entries | map(select(.value > $cutoff)) | from_entries' > "${CLOSED_PRS_FILE}.tmp"
            mv "${CLOSED_PRS_FILE}.tmp" "$CLOSED_PRS_FILE"
          fi

          echo "Recent merged PRs (last 7 days): $RECENT_MERGED_PRS"
          echo "Recent closed PRs (last 7 days): $RECENT_CLOSED_PRS"

          # Create the PR section for README
          echo "## Currently Installed PRs" > /tmp/pr_section.md
          echo "" >> /tmp/pr_section.md

          if [ -n "$UNMERGED_PRS" ]; then
            echo "The following PRs are automatically merged into this fork:" >> /tmp/pr_section.md
            echo "" >> /tmp/pr_section.md

            IFS=',' read -ra PR_ARRAY <<< "$UNMERGED_PRS"
            for PR_NUMBER in "${PR_ARRAY[@]}"; do
              PR_NUMBER=$(echo "$PR_NUMBER" | xargs)
              echo "- [Upstream PR #$PR_NUMBER](https://github.com/jellyfin/jellyfin/pull/$PR_NUMBER)" >> /tmp/pr_section.md
            done

            # Add recently removed section
            if [ -n "$RECENT_MERGED_PRS" ] || [ -n "$RECENT_CLOSED_PRS" ]; then
              echo "" >> /tmp/pr_section.md
              echo "### Recently Removed PRs (Last 7 Days)" >> /tmp/pr_section.md
            fi

            if [ -n "$RECENT_MERGED_PRS" ]; then
              echo "" >> /tmp/pr_section.md
              echo "#### ✅ Merged Upstream" >> /tmp/pr_section.md
              echo "The following PRs were automatically removed as they have been merged into upstream Jellyfin:" >> /tmp/pr_section.md
              echo "" >> /tmp/pr_section.md
              IFS=',' read -ra MERGED_ARRAY <<< "$RECENT_MERGED_PRS"
              for PR_NUMBER in "${MERGED_ARRAY[@]}"; do
                PR_NUMBER=$(echo "$PR_NUMBE
